---
layout: post
title:  "A Bug-Free RISC-V Core without Simulation"
date:   2018-09-03 22:00:00 -0700
categories: RISC-V
---

# Introduction

Earlier, I had a [quick look at SpinalHDL](2018-08-11-SpinalHDL.md) as a candidate to replace Verilog for my hobby projects.

But as much as one can read the documentation and go to some trivial tutorials, you need a real project to see if a language
fits your needs.

Since all the cool kids are designing their own RISC-V cores these days, I felt the need to write one myself as well.

Verifying a CPU the traditional way is error prone and tedious. But with the arrival of 
[SymbiYosys](https://symbiyosys.readthedocs.io/en/latest/), an open source formal verification tool, and with the existence of
[riscv-formal](https://github.com/cliffordwolf/riscv-formal), a RISC-V formal verification test suite, all the components
are in place to design a bug-free RISC-V core without the need to simulate anyting.

# Goals

So that was the plan:

* Get hands-on experience with [SpinalHDL](https://spinalhdl.github.io/SpinalDoc/)
* Design my own minimal [RISC-V](https://riscv.org/specifications/) core
* Use formal verification to ensure correctness

I made it an explicit requirement to not simulate anything before getting a 100% PASS on all the formal tests. 

There were some additional *initial* guidelines for what I wanted the RISC-V code to do:

* performance/cycle had to be better than the ubiquitous [picorv32 RISC-V core](https://github.com/cliffordwolf/picorv32)

    In practice, that's not a very difficult target: the picorv32 is mostly designed for clock speed, but it's IPC
    is pretty bad, requiring at least 3 cycles per instructions and often quite a bit more.

* Get a PASS on *all* the riscv-formal tests

    The biggest consequence of this is that it needs a full instruction decoder. Not only does it need to execute instructions
    correctly, it also needs to NOT execute incorrect instructions. In terms of the riscv-formal test suite, this means that
    an incorrect instruction needs to result in a trap event on the RVFI interface.

* Focus on passing the riscv-formal test as quickly as possible

    In the first round, I didn't want to go out of my way to look at achievable clock speed, minimal area, or maximum IPC (as long
    as it was better than a picorv32.)

* RV32I first, additional features later

    This is a consequence of the previous point. I think compressed instruction support is essential if you want to use
    a RISC-V core for a small, embedded CPU core if you want it to replace a complex control FSM. So it's high on the list
    of desirable features. But it adds a bit of complexity that detracts from the as-quickly-as-possible goal.

    Adding multiplication is really easy, but RV32IM support also implies support for DIV (in the form of a serial divider.)
    I didn't want to bother with that just yet.

* No interrupts, halt, traps

    The riscv-formal test suite doesn't have tests for these, so they are out. I really want to support interrupts and halt eventually.

* No CSRs

    Same thing as for the previou point: when I started the project, there was not support for this in the test suite. Looking at the
    latest commits, support for these are being added.

# 



