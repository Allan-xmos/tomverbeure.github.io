---
layout: post
title:  "A Bug-Free RISC-V Core without Simulation"
date:   2018-09-03 22:00:00 -0700
categories: RISC-V
---

# Introduction

Earlier, I had a [quick look at SpinalHDL](2018-08-11-SpinalHDL.md) as a candidate to replace Verilog for my hobby projects.

But as much as one can read the documentation and checkout some trivial tutorials, you need a real project to see if a language
fits your needs.

Since all the cool kids are designing their own RISC-V cores these days, I felt the need to write one myself as well.

Verifying a CPU the traditional way is error prone and tedious. But with the arrival of
[SymbiYosys](https://symbiyosys.readthedocs.io/en/latest/), an open source formal verification tool, and with the existence of
[riscv-formal](https://github.com/cliffordwolf/riscv-formal), a RISC-V formal verification test suite, all the components
are in place to design a bug-free RISC-V core without the need to simulate anything.

So that was the plan.

# Goals

* Design my own minimal [RISC-V](https://riscv.org/specifications/) core

* Get hands-on experience with [SpinalHDL](https://spinalhdl.github.io/SpinalDoc/)

* Use formal verification to ensure correctness

* Only use SpinalHDL Core

    SpinalHDL comes with a pretty elaborate library. I expicitly did not want to use any of that. One of the reasons
    is that I want to publish my code under an *Unlicense* license: the code is completely public domain
    and anyone can do whatever they want with it. The SpinalHDL Library is published under the MIT License and
    I'm not enough of lawyer to understand the practical consequences of that.

    The other reason is simply that I want to start with the very basics. As I get more proficient, I may
    start using more advanced features.

I made it an explicit requirement to not simulate anything before getting a 100% PASS on all the formal tests.

There were some additional guidelines for what I wanted the RISC-V code to do:

* performance/cycle had to be better than the ubiquitous [picorv32 RISC-V core](https://github.com/cliffordwolf/picorv32)

    In practice, that's not a very difficult target: the picorv32 is mostly designed for clock speed, but its IPC
    is pretty bad, requiring at least 3 cycles per instructions and often quite a bit more.

* Get a PASS on *all* the riscv-formal tests

    The biggest consequence of this is that it needs a full instruction decoder. Not only does it need to execute instructions
    correctly, it also needs to NOT execute incorrect instructions. In terms of the riscv-formal test suite, this means that
    an incorrect instruction needs to be marked as a trap on the RVFI interface. (It does *not* mean that the functional
    CPU should support traps.)

* Focus on passing the riscv-formal test as quickly as possible

    In the first round, I didn't want to go out of my way to look at achievable clock speed, minimal area, or maximum IPC (as long
    as it was better than a picorv32.) One I passed this milestone, I knew that I'd start iterating on one or more of those
    metrics, because optimizing stuff is fun.

* RV32I only at first

    This is a consequence of the previous point. I think compressed instruction support is essential if you want to use
    a RISC-V core for a small, embedded CPU core that replaces a complex control FSM. So it's high on the list
    of desirable features. But it adds a bit of complexity that detracts from the as-quickly-as-possible goal.

    Adding multiplication is really easy, but RV32IM support also implies support for DIV (in the form of a serial divider.)
    I didn't want to bother with that just yet.

* No interrupts, halt, traps

    The riscv-formal test suite doesn't have tests for these, so they are out. I really want to support interrupts and halt eventually.

* No CSRs

    Same thing as for the previou point: when I started the project, there was not support for this in the test suite. Looking at the
    latest commits, support for these are being added.

# Some Earl Design Decisions

* Split instruction and data bus

    The picorv32 has only one bus for both instructions and data. I hate it. :-) You can always go from split to joint if performances
    isn't critical, but you can't do the opposite.

    Since all hobby designs are using FPGAs, and since most FPGA have RAMs that are all true dual-ported memories, you can connect one port
    ot the instruction bus and the other port to the data bus. You never need to join the busses, and you get the best possible performance.

* Separate request and response bus with their own valid/ready

    Initially, my design won't need it, I want to have the option to have multiple read requests in flight.

* 3 stage pipeline: Fetch, Decode, Execute

    In an FPGA, you'll probably want to use RAMs for the register file. These kind of RAMs are almost always synchronous
    and their output delay is often quite long, so you want to clock their outputs without too much logic because
    they'll become the critical path quickly.

    This naturally results in a 3 stage pipeline: issue the register file read in the Fetch stage, reflop the output in Decode,
    use the result in Execute.

    That said, for simplicity, I issues the register file read in Decode, so the output of the RAMs were not reflopped before
    they were used in the Execute stage. As expected, this had a major clock speed impact on my first version.


# Interfacing between Stages

I decided to group all the signals between major functional blocks into a Bundle (think of it as a struct, or as an `interface`
in SystemVerilog.) This makes connecting them at the toplevel really quick. It also makes it very easy and low effort to
add or remove signals between blocks later on.

# First Step: Decoder

I started out with the decoder, where a 32-bit instruction word enters, gets classified into an instruction type (which more or less
corresponds to a 7-bit RISC-V opcode: AUIPC, LUI, ALU, ...), and an instruction format (R, I, J, ...) as defined in the RISC-V
specification.

This type/format combo gets passed on to the next stage, in addition the RVFI interface: this is the interface that's used by
the riscv-formal test suite to observe which instructions are being retired by the CPU, along with the register inputs, register
output, memory transactions, and status (halt, trap, intr, ...)

The CPU core is supposed to decorate the various fields of the RVFI structure as the instructions moves down the pipeline.

When the instruction has completed, the RVFI interface must have rvfi_valid asserted. This is the trigger for the formal suite to
perform various checks. When *all* tests are passing, you can consider the CPU verified.

When there's only a decoder, most of the RVFI fields are completely meaningless: there is no register file yet to fill in the rs1\_data
and rs2\_data fields, there is no ALU to fill in the rd\_data field, and there's no load/store unit to fill in the issued memory
tranactions and the result of them.

But what *can* be filled in is the `trap` field. When an illegal or unsupported instruction is encountered, the `rvfi_trap` field must
be asserted.

Out of the box, the testsuite has an example `complete` test that verifies that the decode issues a `trap` when an invalid instruction
is not flagged as such by the decoder.

The first version of the design with only the decoder can be found [here](https://github.com/tomverbeure/mr1/tree/b61c3c7e43e5bd068304bd8c42c01024bcda0f6e/src/main/scala/mr1).
This code is clean enough to pass all SpinalHDL integrity checks (no mismatching vector widths, no combinational loops, ...) to
covert it into clean Verilog. But it doesn't have the RVFI interface to make a formal check possible.

That happens with [the next version](https://github.com/tomverbeure/mr1/tree/cfb3f6a161918586bd74ab4595afbff775b147da/src/main/scala/mr1).

It adds an pass-through Fetch block and, more important, adds [the RVFI interface](https://github.com/tomverbeure/mr1/blob/cfb3f6a161918586bd74ab4595afbff775b147da/src/main/scala/mr1/Decode.scala#L191-L221).





# Difficulties and Pitfalls

SpinalHDL:

riscv-formal:



